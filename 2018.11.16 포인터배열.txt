C언어 함수(전달인수, 리턴)
20181107 func01~ 함수 시작
20181108 func10~ 전달인수, 리턴
20181109 func
--------------------------------------------------
함수(function)란? 
자주 사용되는 코드를 융통성있게 저장하는 것.
"method"와 같다.

API : 함수들의 집합
Open API: 공개된 소스코드. 함수들의 집합

//void 값이 없다 ->리턴이 없다
//null 주소의 초기 값이 없다 
//void* 주소가 없다
--------------------------------------------------
void func01() 
{
	//fuc01();
	printf("함수1번 콜\n");
}
int main()
{
	srand((signed)time(NULL));
	func01();
}
--------------------------------------------------
void func02() 
{
	//함수는 여러 번 콜 할 수 있다.
	/*printf("1\n");	
	func02();
	printf("2\n");
	func02(); */
	//함수가 콜 되면 안에 있는 것이 모두 출력된다.
	//하향식으로 출력
	printf("함수2번 콜\n");
	printf("라면 먹고\n");
	printf("밥 먹고\n");

}
int main()
{
	srand((signed)time(NULL));
	
	printf("호랑이\n");
	
	printf("1\n");	
	func02();
	printf("2\n");
	func02();

}
--------------------------------------------------
void func03() 
{
	//5단 출력 함수
	printf("5단 출력 시작\n");
	for (short i = 0; i < 10; i++)
	{
		printf("%d * %d = %d\n",5,i,(5*i));
	}printf("\n");
}

int main()
{
	srand((signed)time(NULL));
	func03();
}
--------------------------------------------------
void func04() 
{
	//1~10누적 합산 프로그램
	//for(i=0; i<n; i++) 또는 for(i=1; i<=n; i++)
	//n: 반복 횟수
	printf("1부터 10까지 누적 합\n");
	long sum = 0;
	for (long i = 1; i <= 10; i++)
	{
		sum = sum + i;
		printf("%d\n",sum);
	}printf("총 합은 %d입니다",sum);
}

int main()
{
	srand((signed)time(NULL));
	func04();
}
--------------------------------------------------
void func05() 
{
	//타입
	char a = 10;	//1byte = 8bit
	short b = 20;	//2byte = 16bit
	long c = 30;	//4byte
	int d = 40;		//컴퓨터의 운영체제에 따라 다름
	//기술면접 - long은 반드시 4byte이지만 int는 컴퓨터의 운영체제에 따라 달라집니다.
	float e = 3.14f;//4byte,실수  //소수점은 연산에러 날 수 있다.
	double f = 3.14;//8byte,실수  //정밀한 제어 위해 사용
	bool g = true;	//1byte, true false 저장  
	//구조체 타입

	printf("%d \n",sizeof(char));	//1
	printf("%d \n",sizeof(short));	//2
	printf("%d \n",sizeof(long));	//4
	printf("%d \n",sizeof(int));	//4
	printf("%d \n",sizeof(float));	//4
	printf("%d \n",sizeof(double));	//8
	printf("%d \n",sizeof(bool));	//1
	//printf("%d \n",sizeof(내가 만든 구조체 타입));	//구조체타입 크기	
}	

int main()
{
	srand((signed)time(NULL));
	func05();
}
--------------------------------------------------
void func06() 
{
	//signed :양수 음수 사용가능
	//signed 는 default로 생략 가능
	int a = 10;
	int b = -10;
	signed int c = -20; //int c =  -20; 이다
	
	//unsigned :부호가 없다= 양수만 사용 가능. 양수 범위 두배 가능
	unsigned int d = 30;
	//unsigned e = -30; 오류! 

	//unsigned -> 양수 범위 두배 가능
	//char타입) signed 범위 -120~120 //unsigned 범위0~255
	//나이, 볼륨, 색상 값
	signed char e = 150;
	unsigned char f = 150;

	printf("%d \n",e);//-106
	printf("%d \n",f);//150
}

int main()
{
	srand((signed)time(NULL));
	func06();
}
--------------------------------------------------
void func07() 
{	
	//0x:16진수임을 알려준다
	int a = 123;
	int b = 0x123; 
	printf("%d\n",b);//291
	int c = 0xab7;
	printf("%d\n",c);//2743
	//int d = abc7; //16진수가 아님
	
	//0:8진수임을 알려준다
	int e = 386;	//0386;은 오류, [8진수: 0~7]
	int f = 0376;
	printf("%d \n",f);//254
	
	//2진법 표시하는 문법은 없다
}
int main()
{
	srand((signed)time(NULL));
	func07();
}
--------------------------------------------------
void func08() 
{
	//변수, 상수

	//int: 타입//a:변수//=:대입연산자//10:literal
	int a = 10;
	int b = 20;

	//a가 값을 대입 받을 수 있다면, a는 변수
	//값을 대입 받을 수 없다면, 상수
	a = 100;
	b = 200;

	//const 타입 : 변수의 상수화 -> 이후부터 값 대입 못 받음
	//const가 선언되기 전 초기값이 존재해야한다 
	const int c = 30;
	//c = 30; 오류!
	//const int d; 오류! 

	//상수를 사용하는 이유 : 실수로 갱신 못하게
	//고정된 값이 정해져 있을 때 사용
	const int RainbowColorNumber = 7;
	const float PI = 3.14f;

	//20 = 30; 상수는 대입 못 받음
}
int main()
{
	srand((signed)time(NULL));
	func08();
}
--------------------------------------------------
void func09()
{
	printf("함수 9번 콜\n");
/*10진수 16진수	2진수
0	0	0000
1	1	0001
2	2	0010
3	3	0011
4	4	0100
5	5	0101
6	6	0110
7	7	0111
8	8	1000
9	9	1001
10	a	1010
11	b	1011
12	c	1100
13	d	1101
14	e	1110
15	f	1111*/

}
int main()
{
	srand((signed)time(NULL));
	func09();
}
--------------------------------------------------
20181108
--------------------------------------------------
#include "pch.h"
#include <iostream>
#include<time.h>

void func10() {
	//0~100사이의 수 랜덤 출력
	printf("랜덤 100 출력\n");
	for (long a = 0; a < 10; a++)
	{
		//%10 : [0~9]
		long t = rand() % 100;
		printf("%d\n", t);
	}
}
int main()
{
	srand((signed)time(NULL));
	func10();
}
--------------------------------------------------
void func11(int num) {
	//함수에 인수 전달(대입연산)
	//함수를 콜 할때 반드시 인수를 전달해야한다 - 쌍방간의 타입 주의
	//모든 타입 가능하다
	//인수전달 정수를 입력하면 num이 받는다
	printf("꽃다발 %d송이 \n",num); 
	
	////출력
	//func(100); 꽃다발 100송이
}
int main()
{
	srand((signed)time(NULL));
	func11(100);
	//func11(); 오류! 11함수는 인수전달을 기다리고 있다.
}
-----------------------------------------------
void func12(int num)
{
	//전달인수 구구단 출력 함수
	//융통성을 가진다
	printf("%d단 출력 시작\n",num);
	for (short i = 0; i < 10; i++)
	{
		printf("%d * %d = %d\n", num, i, (num * i));
	}printf("\n");
}
int main()
{
	srand((signed)time(NULL));
	func12(8);
}
--------------------------------------------------
void func13(int num) 
{
	//1~전달인수 누적 합산 프로그램
	//for(i=0; i<n; i++) 또는 for(i=1; i<=n; i++)
	//num: 반복 횟수
	printf("1부터 %d까지 누적 합\n",num);
	long sum = 0;
	for (long i = 1; i <= num; i++)
	{
		sum = sum + i;
		printf("%d\n", sum);
	}printf("총 합은 %d입니다", sum);
}

int main()
{
	srand((signed)time(NULL));
	func13(100);
}
--------------------------------------------------
void func14(int a,int b) 
{
	//전달인수는 둘 이상도 가능
	//함수 콜 할때 개수 맞춰서 전달해야한다.
	//void func14(int a,b)의 형태 오류. 받는 타입이 명시되어야한다.  
	
	printf("%d\n",a+b);
	
	////출력
	//func14(10,20); 출력: 30
}
int main()
{
	srand((signed)time(NULL));
	func14(10,20);
}
--------------------------------------------------
void func15(char a,short b,unsigned long c,float d,bool e)
{
	//전달인수는 둘 이상의 타입도 가능
	//%.03f 소수점 자리수 지정
	//출력창에서 Ctrl A, Enter누르면 복사
	printf("%c, %d, %d, %f, %d \n",a,b,c,d,e); //H, 10, 20, 30.000000, 1
	printf("%d, %03d, %3d, %.03f, %d ",a,b,c,d,e);//72, 010,  20, 30.000, 1
	
	////출력
	//func15('H',10,20,30.0f,true);
}
int main()
{
	srand((signed)time(NULL));
	func15('H',10,20,30.0f,true);
}
--------------------------------------------------
void func16(int a, int b) {
	//0~100사이의 수 랜덤 출력
	printf("%d개의 랜덤 0~%d까지 숫자 출력\n",b,a);
	for (long i = 0; i < b; i++)
	{
		//%10 : [0~9]
		long t = rand() % a;
		printf("%d\n", t);
	}
}
int main()
{
	srand((signed)time(NULL));
	func16(8,6);
}
--------------------------------------------------
void func17(char ch, int n) 
{
	//원하는 문자 전달인수만큼 출력
	for (long i = 0; i < n; i++)
	{
		printf("%c ",ch);
	}
	printf("\n");
	
	////출력 
	//func18('H',10);//H 10번 출력
}

int main()
{
	srand((signed)time(NULL));
	func17('H',10);
}
--------------------------------------------------
int func18()
{
	 //기존 사용하던 함수 void는 리턴이 없다는 뜻이다.
	 //함수에서 값을 들고온다.(리턴한다.)
	 //리턴 값은 하나만 가능
	 //반드시 return이 있어야한다.	 

	printf("함수 18번이 콜 되었습니다\n");
	 return 100;

	 ////출력1
	 //func18();리턴된 값을 사용하지 않음
	 
	 ////출력2
	 //int num = func18(); => num에 return값 대입
	 //printf("%d\n",num); 출력: 100

	 ////출력3
	 //printf("%d \n",func18()); 출력: 100
}
int main()
{
	srand((signed)time(NULL));
	
	func18();

	int num = func18();
	printf("%d\n",num);

	printf("%d \n",func18());
}
--------------------------------------------------
int func19() 
{
	//리턴이 있다
	//함수의 리턴값으로 융통성 있게 응용 할 수 있다
	printf("함수 19번이 콜 되었습니다\n");
	printf("%d \n",100);//고정된 값
	return 100;

	////출력
	//printf("%d \n", func19()); 출력 : 함수 19번이 콜 되었습니다 100 100
	//printf("계란 %d개를 요리합니다 \n", func19());
	//printf("라면 %d개를 요리합니다 \n", func19());
	//printf("우동 %d개를 요리합니다 \n", func19());
}

int main()    
{
	srand((signed)time(NULL));
	printf("%d \n",func19());
	printf("계란 %d개를 요리합니다 \n",func19());
	printf("라면 %d개를 요리합니다 \n",func19());
	printf("우동 %d개를 요리합니다 \n",func19());
}
--------------------------------------------------
int func20(int a, int b)
{
	//두 개의 전달인수 합 구해 리턴하기
	printf("함수 20번 콜\n");
	return a + b;

	////출력
	//printf("%d \n", func20(10, 20)); 출력: 함수 20번 콜 30
}
int main()    
{
	srand((signed)time(NULL));
	printf("%d \n",func20(10,20));
}
--------------------------------------------------
int func21(int a, int b) 
{
	//전달인수로 a의 b승 구하기
	int s = 1;
	for (long  i = 0; i < b; i++)
	{
		s = s * a;
	}
	return s;

	////출력
	//printf("%d\n",func21(2,8)); 256
}
int main()    
{
	srand((signed)time(NULL));
	printf("%d\n",func21(2,8));
}
--------------------------------------------------
20181109
--------------------------------------------------
void func22() 
{
	//함수원형 4가지 형태
	//function prototype
	//void funcname(void) 	
	//void funcname(int a,int b,...)//전달되는 인수 O, 리턴 값 X	
	//int funcname(void)//전달되는 인수 X, 리턴 값 O	
	//int funcname(int a,...)//전달되는 인수 O, 리턴 값 O
}
--------------------------------------------------
void func23(int a, int *b) 
{
	//인수전달 = 대입연산
	//int *b는 주소 받기 전에 사용할 수 없다.즉, b는 주소 전달 위치
	//call by value
	//call by address
	
	printf("%d %p %d \n",a,b,*b);

	////출력
	//func23(10, 20); 오류! 두번째 인수는 주소 전달
	//func23(10, &num);//10 0018F7F0 100
}
int main()
{
	srand((signed)time(NULL));
	int num = 100;
	//func23(10, 20); 오류! 두번째 인수는 주소 전달
	func23(10,&num);
}
--------------------------------------------------
void func23(int a, int *b)
{
	//인수전달 = 대입연산
	//int *b는 주소 받기 전에 사용할 수 없다.즉, b는 주소 전달 위치
	//int *b = &num;
	printf("%d %p %d \n", a, b, *b);
	*b = 200;// 공유된 메모리 값 초기화

	////출력
	//func23(10, 20); 오류! 두번째 인수는 주소 전달해야 함 
	//func23(10, &num);//10 0018F7F0 100
	//printf("%d %d\n", num, &num);//20 0018F7F0  *b와 공유됨 확인
}
int main()
{
	srand((signed)time(NULL));
	int num = 100;
	//func23(10, 20); 오류! 두번째 인수는 주소 전달
	func23(10, &num);
	printf("%d %d\n",num,&num);
}
--------------------------------------------------
void func24(int a, int b) 
{
	//일반변수 전달인수 SWOT
	//함수 안에서는 데이터 교환이 일어났으나 {}가 끝나면 일반변수 a,b는 사라짐
	int t = a;
	a = b;
	b = t;
	printf("%d %d \n",a,b);//20 10
	
	////출력
	//int x = 10, y = 20;
	//printf("%d %d \n", x, y);//10 20
	//func24(x, y); //call by value 
	//printf("%d %d \n", x, y);//10 20


}
int main()
{
	srand((signed)time(NULL));
	int x = 10, y = 20;
	printf("%d %d \n",x,y);//10 20
	func24(x,y);
	printf("%d %d \n",x,y);//10 20
}
--------------------------------------------------
void func25(int *a,int *b) 
{
	//포인터변수 전달인수 SWOT
	//전달인수 a,b와x,y는 주소 공유 , {}가 끝나도 포인터 교환상태 유지
	int t = *a;
	*a = *b;
	*b = t;

	////출력
	//int x = 10, y = 20;
	//printf("%d %d \n", x, y);//10 20
	//func25(&x, &y);//call by address
	//printf("%d %d \n", x, y);//20 10
}
int main()
{
	srand((signed)time(NULL));
	int x = 10, y = 20;
	printf("%d %d \n",x,y);//10 20
	func25(&x,&y);
	printf("%d %d \n",x,y);//20 10
}
--------------------------------------------------
void func26(int *num)
{	
	//배열 데이터 10배수 하는 함수
	//배열메모리 공유, 함수에서 값 갱신
	
	for (long i = 0; i < 4; i++)
	{
		num[i] = num[i] * 10;
	}

	////출력
	//int ar[] = { 3,4,5,6 };
	//func26(&ar[0]);
	//for (long i = 0; i < 4; i++)
	//{
	//	printf("%d", ar[i]); //0 10 20 30
	//}printf("\n\n");
}
int main()
{
	srand((signed)time(NULL));
	int ar[] = { 3,4,5,6 };
	func26(&ar[0]);
	
	for (long i = 0; i < 4; i++)
	{
		printf("%d\n",ar[i]);
	}
}
--------------------------------------------------
void func26(int *num, int s)
{	
	// s: 배열의 개수 던지기 위한 변수 

	//printf("%d\n", sizeof(num)); 포인터는 사이즈 못 얻음=> for문 반복 횟수 s로 전달

	//배열 데이터 10배수 하는 함수
	//배열메모리 공유, 함수에서 값 갱신
	
	for (long i = 0; i < s; i++)
	{
		num[i] = num[i] * 10;
	}

	////출력
	//int ar[] = { 3,4,5,6,7 };
	//printf("%d\n",sizeof(ar));//int타입 메모리 5개 =>20byte
	//printf("%d\n",sizeof(ar)/sizeof(int));//실제 배열데이터 개수 :5
	//func26(&ar[0]);
	//for (long i = 0; i < sizeof(ar) / sizeof(int); i++)
	//{
	//	printf("%d\n", ar[i]);
	//}
	//}printf("\n\n");
}
int main()
{
	srand((signed)time(NULL));
	int ar[] = { 3,4,5,6,7 };
	
	printf("%d\n",sizeof(ar));//int타입 메모리 5개 =>20byte
	printf("%d\n",sizeof(ar)/sizeof(int));//실제 배열데이터 개수 :5

	func26(&ar[0], sizeof(ar) / sizeof(int));//배열의 개수를 인수로 던진다.
	
	/*for (long i = 0; i < 5; i++)
	{
		printf("%d\n",ar[i]);
	}*/
	
	//위 코드를 융통성 있게 바꿔보면
	for (long i = 0; i < sizeof(ar) / sizeof(int); i++)//배열의 개수만큼 돌려준다
	{
		printf("%d ",ar[i]);
	}printf("\n\n");
}
--------------------------------------------------
/*void func27(int a[10], int *b)
{
	//배열과 포인트를 인수 전달

	for (long i = 0; i < 4; i++)
	{
		a[i] = i * 10;
		b[i] = i * 10;
	}
}
int main()
{
	srand((signed)time(NULL));
	int ar[4] = { 1,2,3,4 };
	int br[4] = { 1,2,3,4 };
	
	func27(ar,br);//ar공유, br 공유
	
	for (long i = 0; i < 4; i++)
	{
		printf("%d ",ar[i]);
	}printf("\n\n");

	for (long i = 0; i < 4; i++)
	{
		printf("%d ", br[i]);
	}printf("\n\n");
}*/
--------------------------------------------------
void func28(int *a)
{
	for (long i = 0; i < 5; i++)
	{
		a[i] = i;
	}
}
int main()
{
	srand((signed)time(NULL));

	int *p = new int[5];// 할당
	func28(p);//배열과 전달인수 공유
	
	for (long i = 0; i < 5; i++)
	{
		printf("%d ",p[i]);//0 1 2 3 4
	}printf("\n\n");
	delete []p;
}
--------------------------------------------------
void func29(int *a)
{
	//함수가 전달인수로 메모리 할당
	//책임지고 함수가 delete해줘야 한다
	for (long i = 0; i < 5; i++)
	{
		a[i] = i;
	}
	printf("호랑이\n"); //호랑이
	delete[]a;
}
int main()
{
	srand((signed)time(NULL));
	func29(new int[5]);//할당과 동시에 인수 전달, 함수가 delete 해주기
}
--------------------------------------------------
int *func30()
{
	//int *func30()//주소 리턴
	//int* func30() :값이 리턴

	int *p = new int[5];
	printf("함수 30 콜\n");
	return p; //주소 리턴-> main이 메모리 해제 의무
}
int main()
{
	srand((signed)time(NULL));
	//리턴방법 1
	//func30(); * 리턴 값을 받았지만 메모리 누수
	
	//리턴방법 2
	int *t = func30(); //t가 리턴 값을 공유,  해제 의무
	delete []t;
	
	//리턴방법 3
	//printf("%p\n",func30()); * 리턴 값을 받았지만 메모리 누수

	//리턴방법 4
	delete []func30(); //바로 해제
}
--------------------------------------------------
int *func31(int *a)
{	
	//전달인수 O, 주소 리턴
	for (long i = 0; i < 5; i++)
	{
		a[i] = i;
		printf("%d");
	}printf("\n\n");
	return a;
}
int main()
{
	srand((signed)time(NULL));
	//리턴방법 5
	delete []func31(new int[5]); //전달인수 메모리 할당, 리턴 해제
}
--------------------------------------------------
20181112
--------------------------------------------------

#include "pch.h"
#include <iostream>
#include<time.h>
int *func32(int *pp)
{
	//주소 리턴
	for (long i = 0; i < 10; i++)
	{
		pp[i] = i;
	}
	for (long i = 0; i < 10; i++)
	{
		printf("%d ",pp[i]);
	}printf("\n\n");
	return pp;//주소 리턴-> main이 메모리 해제 의무
}
int main()
{
	srand((signed)time(NULL));
	/*
	int *p = new int[10];
	func32(p);
	delete[]p;
	*/

	//한줄로 가능
	delete []func32(new int[10]);
}
--------------------------------------------------
void func33()
{
	//return은 단독으로 사용되면 함수 중단
	
	printf("1 \n");
	return;//단독으로 사용되면 함수 중단된다.
	printf("2 \n"); //출력 안됨
}
int main()
{
	srand((signed)time(NULL));
	func33(); //출력 :1
}
--------------------------------------------------
void func34(int n)
{
	//return용도 1: 함수 중단을 위해 사용하기도 한다.
	if (n<0)//n이 음수라면
	{
		printf("음수는 입력할 수 없습니다.\n");
		return;//함수 중단
		printf("도달할 수 없는 코드.\n");

	}
	if (n%2==0) {
		printf("짝수입니다.\n");
	}
	else {
		printf("홀수입니다.\n");
	}
}
int main()
{
	srand((signed)time(NULL));
	func34(50);
}
--------------------------------------------------
int func35() 
{
	//return의 용도 2: 값 던지기
	//return에 도달하지 못하면 안된다
	int n = 3;
	
	if (n == 4)
	{
		return 100;//return을 무조건 만나야한다.
	}
	else {
		return 200;
	}
	
	//또는 
	/*
	if (n == 4)
	{
		return 100;
	}
	return 200;
	*/
}
int main()
{
	srand((signed)time(NULL));
	printf("%d\n",func35());	
}
--------------------------------------------------
int func36(int n)
{
	//return의 용도 3: break 대신 
	switch (n)
	{
		case 10:
			
			return n * 10; //그냥 두면 break를 만날 수 없다 

					//break;를 아예 삭제해버린다.
	
		
		case 20:
			
			return n * 20;//이 자체가 break;
	
		

		case 30:
			
			return n * 30;
	}
	//switch에서 못만날 경우 여기서 return;
	return 100;
}
int main()
{
	srand((signed)time(NULL));
	printf("%d \n",func36(30));
}
--------------------------------------------------
void func37()
{
	//지역변수 ->{}밖에선 사라짐
	int count = 0;
	count ++;
	printf("%d\n",count);
}
int main()
{
	srand((signed)time(NULL));
	func37();
	func37();
	func37();//1 1 1이 나온다
}
--------------------------------------------------
void func37()
{
	int count = 0;
	count ++;
	printf("%d\n",count);
}

//전역변수
int count = 0;
void func38()
{
	count++;
	printf("%d\n", count);
}
int main()
{
	srand((signed)time(NULL));
	func37();
	func37();
	func37();//1 1 1이 나온다
	func38();
	func38();
	func38();//1 2 3
}
--------------------------------------------------
void func37()
{
	int count = 0;
	count ++;
	printf("%d\n",count);
}

int count = 0;
void func38()
{
	count++;
	printf("%d\n", count);
}

/*
//38과 39의 차이점
38위의 count는 다른 함수에서도 사용 가능
39의 count는 함수 전용 전역변수다-> 다른 함수에서 사용 못함
*/

void func39()
{	
	//static  -> 타이핑은 지역변수라도 컴파일시 전역변수로 변환된다. 
	static int count = 0;//원래 지역변수 -> 전역변수
	count++;
	printf("%d\n", count);
}

int main()
{
	srand((signed)time(NULL));
	func37();
	func37();
	func37();//1 1 1이 나온다
	func38();
	func38();
	func38();//1 2 3
	func39();
	func39();
	func39();//1 2 3
}
--------------------------------------------------
void func40()
{
	//사용증가(대입 증가)
	//b = a++; a의 기존 값을 사용한 후 a가 증가
	//b = a++; a가 가지고 있는 값을 대입한 후 증가
	int a = 3, b;
	b = a++;
	printf("%d %d\n",a,b);//4 3
}
void func41()
{
	//증가 대입
	//b = a++; a가 증가한 후 대입
	int a = 3, b;
	b = ++a;
	printf("%d %d\n", a, b);//4 4
	
	int c = 3, d = 3;
	printf("%d %d\n", c++, ++d);//3 4
	//c는 사용증가, d는 증가사용 확인
	printf("%d %d\n", c, d);//4 4
}
void func42(int a, int b)
{
	printf("%d %d\n", a, b);
}
void func43(int a, int b)
{
	printf("%d %d\n",&a, &b);
}
int main()
{
	srand((signed)time(NULL));
	func40();
	func41();

	printf("------------------\n");
	int x = 3, y = 3;
	func42(x++,++y);//3 4
	func42(x,y);//4 4

	printf("------------------\n");
	//던질때의 a, 받는 a는 전혀 다른 변수다
	int a = 10, b = 20;
	func43(a, b);//1637172 1637176 
	printf("%d %d\n",&a, &b);//1637404 1637392
}
--------------------------------------------------
//배열
//가로 X, cx, width, horizantal
//세로 Y, cy, height, vertical

void func44(int x, int y)
{
	//이중 for문
	for (int a = 0; a < 3; a++)
	{
		for (int b = 0; b < 4; b++)
		{
			//a:0, b:0,1,2,3
			//a:1, b:0,1,2,3
			//a:2, b:0,1,2,3
			printf("[%d, %d] ",a,b);
			/*
			출력 
			[0, 0] [0, 1] [0, 2] [0, 3]
			[1, 0] [1, 1] [1, 2] [1, 3]
			[2, 0] [2, 1] [2, 2] [2, 3]
			*/
		}
		printf("\n");
	}
}
int main()
{
	srand((signed)time(NULL));
	func44(1,2);
}
--------------------------------------------------
void func44(int x, int y)
{
	//이중 for문 융통성 있게
	for (int a = 0; a < y; a++)
	{
		for (int b = 0; b < x; b++)
		{
			//a:0, b:0,1,2,3
			//a:1, b:0,1,2,3
			//a:2, b:0,1,2,3
			printf("[%d, %d] ",a,b);
			/*
			출력 x축: - , y축: ㅣ
			[0, 0] [0, 1] [0, 2] [0, 3]
			[1, 0] [1, 1] [1, 2] [1, 3]
			[2, 0] [2, 1] [2, 2] [2, 3]
			*/
		}
		printf("\n");
	}printf("\n\n");
}
int main()
{
	srand((signed)time(NULL));
	func44(3,6);//(x,y) x축: - , y축: ㅣ
	func44(7,5);//(x,y) x축: - , y축: ㅣ
}
--------------------------------------------------
void func45-1(int x, int y)
{
	//이중 for문 융통성 있게
	for (int a = 0; a < y; a++)
	{
		for (int b = 0; b < x; b++)
		{
			printf("%02d ", rand()%100);
		}
		printf("\n");
	}printf("\n\n");
}
int main()
{
	srand((signed)time(NULL));
	func45(4,3);
}
--------------------------------------------------
void func45-2(int x, int y)
{
	//이중 for문 가로3,세로 4로 100까지 랜덤한 두자리 숫자 
	for (int a = 0; a < y; a++)
	{
		for (int b = 0; b < x; b++)
		{
			printf("%02d ", rand()%100);
			/*
			출력
			56 46 21 69
			68 92 50 66
			90 36 60 09
			*/
		}
		printf("\n");
	}printf("\n\n");
}
int main()
{
	srand((signed)time(NULL));
	func45(4,3);
}
--------------------------------------------------
void func46()
{
	//const :상수화-> 변경 불가
	//ex 01)
	int a = 10;
	a = 20;

	//ex 02)
	const int b = 20;//변수의 상수화, 초기화가 필요하다
	//b = 30; 오류! 더이상 값을 변경할 수 없다

	//ex 03)
	int *c;
	c = new int;
	*c = 10;
	delete c; 

	//ex 04)
	int n = 100;
	const int *d = &n;// 값의 상수화
	//*d = 200; 오류!

	d = new int;
	delete d;

	//ex 05)
	int s = 100;
	int *const e = &s;// 주소의 상수화
	//e = new int; 오류!

	//ex 06)
	int t = 100;
	const int *const f = &t;// 주소와 값의 상수화
	//*f = 10; 오류!
	//f = new int; 오류!

}
int main()
{
	srand((signed)time(NULL));

}
--------------------------------------------------
void func47-1(int *p)
{
	//전달인수 :주소
	for (long i = 0; i < 5; i++)
	{
		p[i] = i;
	}
	for (long i = 0; i < 5; i++)
	{
		printf("%d ",p[i]);
	}printf("\n");
}
int main()
{
	srand((signed)time(NULL));
	int ar[] = {1,2,3,4,5};
	func47(ar);//0 1 2 3 4
}

--------------------------------------------------
void func47(int *p)
{
	//void func47(const int *const p)로 사용한다면
	//const의 용도:데이터 갱신 불가. 데이터의 조작을 막아준다
	//주소도 변경할 수 없다는 것을 강조할 때 사용
	//전달인수 :주소

	for (long i = 0; i < 5; i++)
	{
		p[i] = i;
	}
	for (long i = 0; i < 5; i++)
	{
		int n = rand(); //0~30000까지 랜덤
		if (n==7777)
		{
			p[0] = 9999;
			printf("메롱");
		}
		printf("%d ",p[i]);
	}printf("\n");
}
int main()
{
	srand((signed)time(NULL));
	int ar[] = {1,2,3,4,5};
	func47(ar);//1 2 3 4 5
}
--------------------------------------------------
void func48(...)
{
	//void func48(...) 
	//인수전달이 몇개인지 모를 때 사용
	printf("함수48 콜\n");
}
int main()
{
	srand((signed)time(NULL));
	func48(); //함수48 콜
	func48(3,2,1); //함수48 콜
}
--------------------------------------------------
void func49(int a, int b, ...)
{
	//인수전달이 필수적으로 두개 이상
	printf("함수49 콜\n");
}
int main()
{
	srand((signed)time(NULL));
	//func49(); 오류! 
	func49(3, 2, 1); //함수49 콜
}
--------------------------------------------------
void func50()
{
	printf("함수50 콜\n");
	//printf 함수 원형 : 커서두고 Ctrl + f12
	//int  printf(char const* const _Format, ...);
	
	//리턴값이 int인 함수
	//함수 이름 : printf
	//첫번째 인수: char타입이며, const : 값이나 주소를 절대 변경할 수 없음
	//인수 명: _Format
	//인수는 주소로 받겠다
	//인수는 무조건 하나 이상이다
	//...: 전달인수가 여러개여도 된다
	
	int n = printf("apple");
	printf("\n");
	printf("%d\n",n); //5 글자 수를 리턴한다
	printf("%d\n",printf("AppleBanana ")); //AppleBanana 12 출력내용,글자 수

}
int main()
{
	srand((signed)time(NULL));
	func50();	
}
--------------------------------------------------
void func51()
{
	char ar[] = {10,20,30,40,50,60,70};
	for (long i = 0; i < 7; i++)
	{
		printf("%d ",ar[i]);
	}printf("\n");//10 20 30 40 50 60 70

	//http://www.soen.kr/ 사이트 참고
	//memset();
	//memset()의 용도: 값의 빠른 초기화
	//memset(ar,0,7); ar의 7개 메모리를 0으로 바꾼다
	memset(ar,50,3); //ar의 3개 메모리를 50으로 바꾼다
	for (long i = 0; i < 7; i++)
	{
		printf("%d ", ar[i]);
	}printf("\n");

}
int main()
{
	srand((signed)time(NULL));
	func51();	
}
--------------------------------------------------
void func51_2()
{
	char ar[] = {10,20,30,40,50,60,70,80};
	int size = sizeof(ar);
	for (long i = 0; i < size; i++)
	{
		printf("%d ",ar[i]);
	}printf("\n");//10 20 30 40 50 60 70

	memset(ar,50,6); //ar의 3개 메모리를 50으로 바꾼다
	for (long i = 0; i < size; i++)
	{
		printf("%d ", ar[i]);
	}printf("\n");
	//memset()의 용도: 값의 빠른 초기화
}
int main()
{
	srand((signed)time(NULL));
	func51_2();	
}
--------------------------------------------------
20181113
--------------------------------------------------
#include "pch.h"
#include <iostream>
#include<time.h>
struct STRU52{
	int a, b;
};

void func52(int n, STRU52 s) {
	printf("%d %d %d\n",n, s.a, s.b);
}

int main()
{
	srand((signed)time(NULL));
	STRU52 s = { 10,20 }; //함수 전달인수와 다름
	printf("%d %d\n",s.a,s.b);
	func52(100,s); //100 10 20
	
	//데이터 갱신
	s.a = 77;//
	s.b = 88;

	func52(200,s);//200 77 88
}
--------------------------------------------------
struct STRU53 {
	int num;
	int *ptr;
};
void func53(STRU53 s) {
	printf("%d %d %d\n",s.num,*s.ptr, s.ptr);//값을 하나 출력하고, 주소를 하나 출력하겠다.
}

int main()
{
	srand((signed)time(NULL));
	STRU53 t;
	t.num = 10;
	t.ptr = &t.num; //*ptr 주소 공유
	func53(t);//1 0 10 1637852

	t.ptr = new int;//주소 할당
	*t.ptr = 20;
	func53(t);
	delete t.ptr;//10 20 11549952
}
--------------------------------------------------
struct STRU54 {
	int num;
	int *ptr;
};

void func54(STRU54 *s) {
	//전달인수가 구조체 *s
	//받는 인수가 주소
	printf("%d %d %d\n",s->num,*s->ptr,s->ptr);

}
int main()
{
	srand((signed)time(NULL));
	STRU54 t;
	t.num = 10;
	t.ptr = new int;
	*t.ptr = 10;
	func54(&t);//받는인수가 주소 10 10 11460560
	delete t.ptr;
	
	STRU54 *st;
	//func54(st); //문법 상으로는 문제가 없으나, st는 주소 받고 사용해야한다
	st = new STRU54;
	st->num = 20;
	st->ptr = new int;
	*st->ptr = 30;
	func54(st);//20 30 11460560
	delete st->ptr;
	delete st;
}
--------------------------------------------------
struct STRU55{
	int a, b;
};
STRU55 func55(STRU55 xx, STRU55 yy) {
	//구조체 타입 리턴 값 있는 함수
	//struc55 func55(STRU55 xx, STRU55 yy) 
	STRU55 result;
	result.a = xx.a + yy.a;
	result.b = xx.b - yy.b;
	return result;
	//return &result; 오류!
}
int main()
{
	srand((signed)time(NULL));
	STRU55 s1 = { 10, 20 };
	STRU55 s2 = { 30, 40 };
	
	//return받기 방법 1
	func55(s1,s2);// 공중에 사라진다

	//return받기 방법 2
	STRU55 s3 = func55(s1,s2); //값 받기
	printf("%d %d \n",s3.a,s3.b); //값 출력 //50 -20//result.a result.b 출력
}
--------------------------------------------------
int *func56() {
	//warning C4172: 지역 변수 또는 임시: a의 주소를 반환하고 있습니다.
	//int type의 *이 리턴 =>주소가 리턴된다
	int a = 10;
	return &a;

}//지역변수인 a메모리 사라짐
int main()
{
	srand((signed)time(NULL));
	int *pp = func56(); //존재하지 않는 메모리를 사용한다
	//printf("%d %d \n",*pp, pp);//10 1636476 //작동은 되나 큰일날 프로그램
	*pp = 100;
}
--------------------------------------------------
int *func57(){
	//int type의 *이 리턴 =>주소가 리턴된다
	int *pp = new int;
	return pp;
}//new 는 delete를 쓸 때만 사라지는 메모리
int main()
{
	srand((signed)time(NULL));
	int *pp = func57();
	delete pp;
}
--------------------------------------------------
////#define
//앞으로 나올 APPLE58은 10으로 바꾼다
//용도 : 코드의 유지보수를 위해 사용한다
//#define은 마지막에 ;를 붙이지 않는다 ->원래 있던 문장에 오류생김
//이름에 대문자를 사용한다
//옆에 주석처리도 하지 않는다
//컴파일 될 때 바꿔치기가 일어난다 대치가 일어난다
//연산은 괄호를 사용한다
//((3)+(4)) 이렇게 다 괄호를 써주는 것이 좋다

//매크로 함수
	//#define KIWI58(a,b)((a)+(b))
	//#define은 함수처럼 사용 가능 =>매크로 함수
	//일반함수와 다른점1 : type의 제한이 없다.
	//일반함수와 다른점2 : 속도가 훨씬 빠르다 //매크로는 콜이 아님. 코드 바꿔치기실행
	//일반함수와 다른점2 : 코드의 가독성이 떨어질 수 있다.

#define APPLE58 10
#define BANANA58 20+30
#define ORANGE58 (3+4)
#define MELON58 ((3)+(4))
#define KIWI58(a,b)((a)+(b))
void func58() 
{
	//#define APPLE58 10
	printf("%d \n",APPLE58);//10
	printf("%d \n",APPLE58+10);//20

	//#define BANANA58 20+30
	printf("%d \n", BANANA58);//50
	printf("%d \n", BANANA58 + 10);//60

	//#define ORANGE58 (3+4)
	//printf("%d \n", ORANGE58*ORANGE58);//19(3+4*3+4) 원하는 값(7*7 = 49)이 안나옴
	printf("%d \n", ORANGE58*ORANGE58);//49 따라서 ORANGE할때 ()해주기

	//#define MELON58 ((3)+(4)) => 더 정확하게 하기

	//#define KIWI58(a,b)((a)+(b))
	printf("%d \n", KIWI58(5,8));//13

//#include<windows.h> 해주기
	//max(): 큰 수 골라주는 함수
	//min(): 작은 수 골라주는 함수
	printf("%d %d\n",max(3,4),min(10,20)); //4 10

}
int main()
{
	func58();
}
--------------------------------------------------
#include "pch.h"
#include <iostream>
#include<time.h>
#include<windows.h>

void func59(int a, int b, int c, int d) {
	//전달인수 중 가장 큰 값 골라주기
	int r1 = max(a, b);
	int r2 = max(c, d);
	int r3 = max(r1, r2);
	printf("%d \n",r3);
}
int main()
{
	func59(7,5,15,13);//15
}
--------------------------------------------------
#include "pch.h"
#include <iostream>
#include<time.h>
#include<windows.h>

void func60_1() {
	/*
	00 01 02 03
	04 05 06 07
	08 09 10 11
	*/
	
	
	int s = 0;
	for (long i = 0; i < 3; i++)
	{
		for (long i = 0; i < 4; i++)
		{
			
			printf("%02d ",s);
			s = s++;
		}printf("\n");
	}
}
int main()
{
	func60();
}
--------------------------------------------------
void func60_2() {
	/*
	00 01 02 03
	10 11 12 13
	20 21 22 23
	*/
	
	int s = 0;
	for (long i = 0; i < 3; i++)
	{

		for (long j = 0;j < 4; j++)
		{			
			printf("%d%d ",i,j);
		}printf("\n");
	}
}
int main()
{
	func60();
}
--------------------------------------------------
#define APPLE61 10

//typedef char robot;
	// 타입은 내가 새롭게 정의한다
	//robot이란 단어가 나오면 무조건 char타입
typedef char robot;
//용도 1: 오타 방지용
typedef char CHAR;
//용도 2: 철자가 긴 단어를 약어로 쓰고싶을 때
typedef unsigned char UC;
typedef unsigned int UNIT;
//용도 3: 타입의 byte를 알리는 목적
typedef unsigned char BYTE; //1: byte
typedef unsigned short WORD; //word: 2byte
typedef unsigned long DWORD; //dword: 4byte //double word
//용도 4: 소스의 가독성을 높인다. 
//변수가 가지고 있는 속성을 설명해준다.
typedef int BIGDATA; 
typedef int ERR;
typedef int NETWORK_STATE;
typedef int BOOK;
//이중삼중 찾는 것도 가능
typedef BOOK TIGER; //TIGER가 BOOK이 되고 int로 변환
void func61()
{
	char a = 10;
	robot b = 20;
	char c = 20;
	UC d = 200;
	BIGDATA e = 300;
	ERR f = 400;

	//모르는 타입이 나오면 Ctrl +f12 로 확인해보기
	UINT g;
	size_t h = 0;

	//자주보게되는 용어
	//byte //word //dword //BYTE //WORD //DWORD 
}
int main()
{
	
}
--------------------------------------------------
//LPLION이 나오면 int *이 된다
//포인터로 변환되는 것은 모두 LP를 붙인다
//LP : LongPoint의 약자 
typedef int LION;
typedef int *LPLION; 
typedef int *PLION;

//한줄로 나타내기
typedef int CAT,*LPCAT,*PCAT;

void func62()
{
	LPLION a; //int *a;
	a = new int(); //포인트변수임을 확인
	int b;
	//b = new int(); 오류! 일반변수는 주소 할당 못함

	CAT c = 10;
	PCAT d = new int;
	PCAT e = new CAT;

	*d = 20;
	*e = 30;

	delete d;
	delete e;

}
--------------------------------------------------
//구조체도 새로운 Type을 정의할 수 있다.
typedef struct tagSTRU63{
	int a, b;
}STRU63, *LPSTRU63, *PSTRU63;

STRU63; //STRU63선언
void func63() {
	tagSTRU63 xxx;
	xxx.a = 10;
	xxx.b = 20;

	LPSTRU63 yyy = new STRU63; //포인터변수
	yyy->a = 30;
	yyy->b = 40;
	delete yyy;
	
	PSTRU63 zzz = new STRU63;
	delete zzz;	
}
--------------------------------------------------
void func64_1() {
	//표준 제공 구조체 

	SIZE s; //표준 제공 함수
	/*
	Ctrl + f12 검색

	typedef struct tagSIZE
	{
	    LONG        cx;
		LONG        cy;
	} SIZE, *PSIZE, *LPSIZE;

	*/

	POINT p;
	/*
	typedef struct tagPOINT
	{
		LONG  x;
		LONG  y;
	} POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;
	*/

	RECT r;
	/*
	typedef struct tagRECT
	{
		LONG    left;
		LONG    top;
		LONG    right;
		LONG    bottom;
	} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;
	*/
}
--------------------------------------------------
void func64_2() {
	//표준 제공 구조체 

	SIZE s; //표준 제공 함수
	/*
	//[Ctrl + f12 검색]
	typedef struct tagSIZE
	{
	    LONG        cx;
		LONG        cy;
	} SIZE, *PSIZE, *LPSIZE;
	*/

	POINT p;
	/*
	typedef struct tagPOINT
	{
		LONG  x;
		LONG  y;
	} POINT, *PPOINT, NEAR *NPPOINT, FAR *LPPOINT;
	*/

	RECT r;
	/*
	typedef struct tagRECT
	{
		LONG    left;
		LONG    top;
		LONG    right;
		LONG    bottom;
	} RECT, *PRECT, NEAR *NPRECT, FAR *LPRECT;
	*/

	BITMAPINFOHEADER bih;
	/*
	typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
	} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;
	*/
	bih.biBitCount = 10;

	LPBITMAPINFOHEADER p_bih = new BITMAPINFOHEADER;
	p_bih->biBitCount = 20;
	delete p_bih;
}

--------------------------------------------------
typedef struct tagSTRUC65 {
	int a, b;
}STRU65, *LPSTRU65,*PSTRU65;
void func65(int num, STRU65 s,LPSTRU65 p_s) {
	s.a = 10;
	printf("%d %d %d %d \n", s.a, &s.a, p_s->a, &p_s);

}
int main()
{
	STRU65 s1 = {30,40};
	func65(10,s1,&s1);// 10 1637132 30 1637140
}
--------------------------------------------------
20181115
--------------------------------------------------

void func66() {
	for (long i = 0; i < 5; i++)
	{
		printf("%d \n", i);
		//#include<windows.h> 걸기

		Sleep(1000);
		//Sleep();
		//1초 : 1000ms이라 한다
		//프로그램의 진행이 1초 쉬었다 진행된다
	}
}

int main()
{
	func66();
}
--------------------------------------------------
//블로킹상태 : 특정 조건 때문에 프로그램이 더 이상 진행하지 못하고 조건을 충족하면 진행이 이어진다
//ex) scanf_s //Sleep //connect
void func67() {
	for (long i = 0; i < 5; i++)
	{
		printf("%d \n", i);
		Sleep(1000);
		system("cls");
		//콘솔 창을 지워버린다
	}
}
int main()
{
	func66();
}
--------------------------------------------------
void func68() {
	for (long i = 0; i < 5; i++)
	{
		//문자열 관리
		//모든 랭귀지는 일반적으로 문자열은 변경 혹은 조작할 수 없다
		const char *a = "apple";
		//a[0] = 'b'; 이렇게 갱신할 수 없다

		//문자 열 출력
		printf("%s\n", a); //apple
						   //문자 한자 한자 출력
		printf("%c %c\n", a[0], *(a + 4));//a e

		char b[] = "apple";
		//char b[] = "apple";//배열은 초기화할때 []크기 지정 안해도 된다
		//char b[5+1] = "apple";//apple이 어디서 끝나는지 마킹하기 위해 null을 사용-> +1을 더 쓴다
		//char b[6] = "apple";
		//메모리 NULL확인
		if (b[5] == NULL)
		{
			printf("1\n");
		}
		else
		{
			printf("2\n");

		}//1
	}
}

--------------------------------------------------
void func69() {
	////다차원배열
	int ar[5]; //일차원배열
	int br[2][5];//이차원배열 :5개짜리가 2개있다 ->10개 요구
	int cr[2][3][4];//삼차원배열 :4개짜리가 3개있다(12개) *2개 ->24개

	br[0][0] = 10;
	br[1][3] = 20;
	br[2][3] = 30;
	printf("%d %d %d\n", br[0][0], br[1][3], br[2][3]); //10 20 30

														//일반적으로 이차원배열을 사용할 땐 이중for문과 잘 쓰인다.
	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 4; j++)
		{
			printf("(%d %d) %d ", i, j, &br[i][j]);
		}printf("\n");
		//br[][]주소가 4씩 증가하는 거 확인
	}
}
--------------------------------------------------
void func70() 
{
	int br[3][4] = { 0 };//0으로 초기화
	int cr[3][4] = {
		//일반적으로 0으로 초기화하는 경우가 아닐 때
		10,20,30,40,
		50,60,70,80,
		90,80,70,60
		//이중 for문 모양에 맞춰 선언
	};

	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 4; j++)
		{
			//printf("%d ", br[i][j]);
			printf("%d ", cr[i][j]);
		}printf("\n");
		//br[][]주소가 4씩 증가하는 거 확인
	}
}
--------------------------------------------------
	void func71()
{
	int br[3][4] = { 0 };//0으로 초기화
	int cr[3][4] = {
		//일반적으로 0으로 초기화하는 경우가 아닐 때
		10,20,30,40,
		50,60,70,80,
		90,80,70,60
		//이중 for문 모양에 맞춰 선언
	};

	//정석 형태 : {}가 있음
	int dr[3][4] = {
		{ 10,20,30,40 },
	{ 50,60,70,80 },
	{ 90,80,70,60 }
	};

	//앞에[]은 생략 가능,뒤의 []생략 불가능
	int er[][4] = {
		10,20,30,40,
		50,60,70,80,
		90,80,70,60,
		90,80,70,60
	};

	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 4; j++)
		{
			//printf("%d ", br[i][j]);
			printf("%d ", cr[i][j]);
		}printf("\n");
		//br[][]주소가 4씩 증가하는 거 확인
	}
}
--------------------------------------------------
void func72() {
	//문자 이중배열
	char a[4 + 1] = "abcd";
	char b[5] = {
		'a','b','c','d','e'
		//하나씩 값을 넣을땐 'e'까지 넣을 수 있다
	};
	char c[3][4] = {
		'a','b','c','d',
		'e','f','g','h',
		'i','j','k','l'
	};
	char d[3][4 + 1] = {
		//char d[3][4]는 "abcd" 못쓴다
		//[3]은 생략 가능
		"abcd",
		"efgh",
		"ijkl"
	};
	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 4; j++)
		{
			printf("%c ", d[i][j]);
		}printf("\n");
	}
}
--------------------------------------------------
void func73() {

	int x = 2, y = 3;
	while (1)
	{
		char map[12][16 + 1] = {
			"################",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"################"
		};

		map[y][x] = 'O';
		//O가 대각선으로 이동함
		x++;
		y++;
		//배열의 범위를 넘어가면 터지게된다
		for (long i = 0; i < 12; i++)
		{
			for (long j = 0; j < 16; j++)
			{
				printf("%c ", map[i][j]);
			}printf("\n");
		}

		Sleep(700);
		system("cls");
	}
}
--------------------------------------------------
과제
--------------------------------------------------

#include "stdafx.h"
#include <iostream>
#include<time.h>
#include<windows.h>



void func73() {

	int x = 2, y = 3;
	while (1)
	{
		char map[12][16 + 1] = {
			"################",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"################"
		};

		map[y][x] = 'O';
		//O가 대각선으로 이동함
		
		x++;
		y++;
		//배열의 범위를 넘어가면 터지게된다
		for (long i = 0; i < 12; i++)
		{
			for (long j = 0; j < 16; j++)
			{
				printf("%c ", map[i][j]);
			}printf("\n");
		}

		Sleep(700);
		system("cls");
	}
}

int main()
{
	//for (long i = 0; i < 5; i++)
	//{
	//	printf("%d \n", i);
	//	Sleep(1000);
	//	system("cls");
	//	//같은 자리에서 출력이 진행된다
	//}

	int x = 2, y = 3;
	while(1)
	{
		char map[12][16 + 1] = {
			"################",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"################"
		};

		map[y][x] = 'O';
		if (x==15) {
			x--;
		}
		x++;
		
		

		for (long i = 0; i < 12; i++)
		{
			for (long j = 0; j < 16; j++)
			{
				printf("%c ", map[i][j]);
			}printf("\n");
		}
		Sleep(100);
		system("cls");


	}
}
	
	


--------------------------------------------------
연습 중
int main()
{
	//for (long i = 0; i < 5; i++)
	//{
	//	printf("%d \n", i);
	//	Sleep(1000);
	//	system("cls");
	//	//같은 자리에서 출력이 진행된다
	//}

	int x = 2, y = 3;
	while(1)
	{
		char map[12][16 + 1] = {
			"################",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"#..............#",
			"################"
		};

		map[y][x] = 'O';
		
		if (x==15) {
			x--;
			while (1) {
				x--;
				if (x==1) {
					break;
				}
		
			}
		}
		x++;
		
		

		for (long i = 0; i < 12; i++)
		{
			for (long j = 0; j < 16; j++)
			{
				printf("%c ", map[i][j]);
			}printf("\n");
		}
		Sleep(100);
		system("cls");


	}
}
--------------------------------------------------
20181116
--------------------------------------------------
#include "stdafx.h"
#include <iostream>
#include<time.h>
#include<windows.h>

void func74() {
	//포인트 변수 다섯개 주세요
	int *a, *b, *c, *d, *e;
	int *a0, *a1, *a2, *a3, *a4;
	
	//포인트 변수 배열-> 한번에
	int *ar[5];
	
	ar[0] = new int;//할당

	ar[1] = new int[5]; //할당

	int num = 100;
	ar[2] =	&num; //공유

	int br[10] = { 0 };
	ar[3] = &br[0]; //공유

	ar[4] = ar[3]; //공유

	// 사용
	*ar[0] = 100; //값 대입

	printf("%d \n",*ar[0]); //100

	////*ar[1] 사용 - 5개 할당
	//*(ar[1]+0)//내용
	//ar[1][0] //토끼 거북이 ar[1]의 0번
	ar[1][0] = 1;
	ar[1][1] = 2;
	ar[1][2] = 3;
	ar[1][3] = 4;
	ar[1][4] = 5;
	for (long i = 0; i < 5; i++)
	{
		printf("%d ",ar[1][i]);
	}printf("\n");//1 2 3 4 5

	////*ar[2] 사용 - int num공유
	*ar[2] = 200;
	printf("%d \n",num); //200

	////*ar[3]사용 - br[10]과 공유
	for (long i = 0; i < 10; i++)
	{
		ar[3][i] = i*10;
	}
	for (long i = 0; i < 10; i++)
	{
		printf("%d ",br[i]);
	}printf("\n");//0 10 20 30 40 50 60 70 80 90 

	////*ar[4] 사용 - *ar[3]과 공유
	for (long i = 0; i < 10; i++)
	{
		printf("%d ", ar[4][i]);
	}printf("\n");//0 10 20 30 40 50 60 70 80 90 

	//메모리 해제
	delete ar[0];
	delete[] ar[1];
}
int main()
{
	func74();
}
--------------------------------------------------
void func75() {
	int *ptr[3];

	//*ptr[] 4개 주세요
	
	//하나하나
	/* 
	ptr[0] = new int[4]; 
	ptr[1] = new int[4];
	ptr[2] = new int[4];
	*/

	//for문
	for (long i = 0; i < 3; i++)
	{
		ptr[i] = new int[4];
	}
	//이 코드 이후부터 int ptr[3][4]; 의 문법과 완전 동격이다. 

	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 3; j++)
		{
			ptr[i][j] = i * 4 + j ;
		}
	}
	for (long i = 0; i < 3; i++)
	{
		for (long j = 0; j < 3; j++)
		{
			printf("(%02d) %d ",ptr[i][j],&ptr[i][j]);
		}printf("\n");
	}printf("\n\n");

	//주소를 보면 [][]과 *a[]의 차이점을 알 수 있다
	//[3][4] : 12개를 연속적으로 준다 -> 주소 12개가 연속적으로 +4
	//*a[3] = new int[4] : 4개 요구, 4개요구, 4개요구  => 주소가 4개씩만 연속 * 3

	//메모리 해제
	for (long i = 0; i < 3; i++)
	{
		delete[] ptr[i];
	}
}
int main()
{
	func75();
}
--------------------------------------------------
void func76() {
	//------- *[](포인트배열)을 사용하는 이유 -------
	//	[][]의 경우 메모리 낭비가 심할 수 있다 ex)이름등록
	//	*[]의 경우 필요한 만큼 메모리를 요구 => 융통성
	//	[a][b]의 세로길이(a)는 알지만 가로길이(b)를 알지 못할 경우
	////c프로그램은 제어에 따라 최적화가 가능하다 <=메모리 낭비가 덜함
}
int main()
{
	func75();
}
--------------------------------------------------
void func76() {
	//------- *[](포인트배열)을 사용하는 이유 -------
	//	[][]의 경우 메모리 낭비가 심할 수 있다 ex)이름등록
	//	*[]의 경우 필요한 만큼 메모리를 요구 => 융통성
	//	[a][b]의 세로길이(a)는 알지만 가로길이(b)를 알지 못할 경우
	////c프로그램은 제어에 따라 최적화가 가능하다 <=메모리 낭비가 덜함

	//메모리 선언
	int *ptr[6];
	
	//메모리 할당 - 1씩 증가하게
	for (long i = 0; i < 6; i++)
	{
		ptr[i] = new int[i+1];
		//1개주세요, 2개, 3개,... 
	}
	
	//메모리 값 초기화 - 0부터 1씩 증가
	int ct = 0;
	
	for (long i = 0; i < 6; i++)
	{
		for (long j = 0; j < (i+1); j++)
		{
			//i->0번, j->1번 돈다
			ptr[i][j] = ct;
			ct++;
		}
	}
	
	//데이터 출력	
	for (long i = 0; i < 6; i++)
	{
		for (long j = 0; j < (i+1); j++)
		{
			printf("%02d ",ptr[i][j]);
		}printf("\n");
	}printf("\n\n");

	//메모리 해제
	for (long i = 0; i < 6; i++)
	{
		delete[] ptr[i];
	}
}

int main()
{
	func76();
}
--------------------------------------------------
void func77() {
	char ar[10] = "apple";
	printf("%d %d \n",sizeof(ar),strlen(ar));
	//sizeof(ar): 배열의 크기//10
	//strlen(ar): 문자열의 길이//5

	char br[10] = "어흥어흥" ;
	printf("%d %d \n", sizeof(br), strlen(br));
	//sizeof(ar): 배열의 크기//10
	//strlen(ar): 문자열의 길이//8
	//한글은 한 글자당 2byte를 차지한다
	/*
	
	while (1) {
		
		char cr[20];
		//키보드로부터 문자열을 입력 받을 때
		//문자열을 입력 받으면 cr에 넣어라
		printf("문자열을 입력하세요\n");
		scanf_s("%s",cr);
		printf("당신이 입력한 문장열은 %s이고, 그 길이는 %d 입니다.",cr,strlen(cr));
		
	}
	*/
}

int main()
{
	func77();
}
--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------

--------------------------------------------------